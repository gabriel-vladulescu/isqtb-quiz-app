{
  "examId": "sample-exam-d",
  "examName": "ISTQB CTFL Sample Exam D v1.5",
  "version": "1.5",
  "releaseDate": "2025-05-02",
  "syllabusVersion": "4.0",
  "isOfficial": true,
  "totalQuestions": 40,
  "totalPoints": 40,
  "passingScore": 26,
  "questions": [
    {
      "id": 1,
      "questionText": "Which of the following is a typical test objective?",
      "options": [
        {
          "key": "a",
          "text": "Finding and fixing defects in the test object"
        },
        {
          "key": "b",
          "text": "Maintaining effective communications with developers"
        },
        {
          "key": "c",
          "text": "Validating that legal requirements have been met"
        },
        {
          "key": "d",
          "text": "Building confidence in the quality of the test object"
        }
      ],
      "correctAnswer": [
        "d"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. Finding and fixing defects in the test object is not a typical test objective as although identifying defects is an objective of testing, fixing defects is not a test activity",
        "b": "Is not correct. Maintaining effective communications with developers is not a typical test objective although it is useful in achieving other objectives of testing, such as providing stakeholders with information that enables them to make informed decisions. It is not a primary reason for performing testing",
        "c": "Is not correct. Validating that legal requirements have been met is not a typical test objective because validation is concerned with checking whether the system meets users' and other stakeholders' needs in its operational environment. Checking that legal requirements have been met is a form of verification",
        "d": "Is correct. Building confidence in the quality of the test object is achieved by executing tests that passed"
      },
      "learningObjective": "FL-1.1.1",
      "kLevel": "K1",
      "points": 1
    },
    {
      "id": 2,
      "questionText": "A designer documents a design for a user interface that does not suitably address disabled users because the designer is tired. The programmer implements the user interface in line with the design but as they are working under severe time pressure, they do not include suitable exception handling in their program code for bonus calculations. When the operational system is used, complaints are made by some disabled users about the interface and the company is subsequently fined by the relevant regulatory authority. No one notices that bonus calculations are sometimes incorrect.\n\nWhich of the following statements is CORRECT?",
      "options": [
        {
          "key": "a",
          "text": "The miscalculation of bonuses is a defect that occasionally occurs"
        },
        {
          "key": "b",
          "text": "The fine received for failing to address some disabled users is a failure"
        },
        {
          "key": "c",
          "text": "The programmer working under severe time pressure is a root cause"
        },
        {
          "key": "d",
          "text": "The design of the user interface includes a designer error"
        }
      ],
      "correctAnswer": [
        "c"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. The miscalculation of bonuses is a failure by the system, not a defect",
        "b": "Is not correct. The system not suitably supporting disabled users is a failure which eventually results in a fine, but the fine itself is not a failure (it appears to be the correct functioning of the regulatory system)",
        "c": "Is correct. The error is made by the programmer and this mistake is caused by them working under severe time pressure, which is the root cause of the subsequent defect",
        "d": "Is not correct. The poor design of the user interface, which does not suitably address disabled users, is a design defect caused by the designer error. Thus the design of the user interface includes a design defect not a designer error"
      },
      "learningObjective": "FL-1.2.3",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 3,
      "questionText": "Test conditions are being used by testers to generate test cases and execute tests. Even though the test conditions remain the same, the test cases are varied each time. Which of the following 'principles of testing' is being addressed through the variation of test cases?",
      "options": [
        {
          "key": "a",
          "text": "Tests wear out"
        },
        {
          "key": "b",
          "text": "Absence-of-defects fallacy"
        },
        {
          "key": "c",
          "text": "Early testing saves time and money"
        },
        {
          "key": "d",
          "text": "Defects cluster together"
        }
      ],
      "correctAnswer": [
        "a"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is correct. The 'tests wear out' principle is concerned with the idea that repeating identical tests on unaltered code is unlikely to uncover novel defects and therefore, modifying tests may be essential. By using test conditions to generate new tests each time, the tests will not be identical and the risk of the tests wearing out is reduced",
        "b": "Is not correct. The 'absence-of-defects fallacy' principle is concerned with ensuring that users' needs are fulfilled even if lots of testing is done and no defects are found (i.e., validation is also necessary). The use of test conditions to generate test cases and execute tests does not directly address this concern",
        "c": "Is not correct. The 'early testing saves time and money' principle is concerned with fixing defects early on to prevent the occurrence of subsequent defects in derived work products, thereby reducing costs and the likelihood of failures. This is typically addressed by starting testing (both static and dynamic) as early as possible, but this is not addressed by using test conditions to generate test cases and execute tests",
        "d": "Is not correct. The 'Defects cluster together' principle is concerned with the distribution of defects in a system, which typically follows a Pareto distribution. The use of test conditions to generate test cases and execute tests does not address this concern, which is typically addressed by risk-based testing"
      },
      "learningObjective": "FL-1.3.1",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 4,
      "questionText": "Given the following test tasks:\n1. Derive test cases from test conditions\n2. Identify reusable testware\n3. Organize test cases into test procedures\n4. Evaluate the test basis and the test object\n\nAnd the following test activities:\nA. Test analysis\nB. Test design\nC. Test implementation\nD. Test completion\n\nWhich of the following BEST matches the tasks with the activities?",
      "options": [
        {
          "key": "a",
          "text": "1B, 2A, 3D, 4C"
        },
        {
          "key": "b",
          "text": "1B, 2D, 3C, 4A"
        },
        {
          "key": "c",
          "text": "1C, 2A, 3B, 4D"
        },
        {
          "key": "d",
          "text": "1C, 2D, 3A, 4B"
        }
      ],
      "correctAnswer": [
        "b"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct",
        "b": "Is correct. The CORRECT match is: 1B (Derive test cases from test conditions is Test design), 2D (Identify reusable testware is Test completion), 3C (Organize test cases into test procedures is Test implementation), 4A (Evaluate the test basis and the test object is Test analysis)",
        "c": "Is not correct",
        "d": "Is not correct"
      },
      "learningObjective": "FL-1.4.1",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 5,
      "questionText": "Given the following testware:\ni. Test completion report\nii. Data held in a database used for test inputs and expected results\niii. The list of elements needed to build the test environment\niv. Documented sequences of test cases in execution order\nv. Test cases\n\nWhich of the following BEST shows the testware produced as a result of performing test implementation?",
      "options": [
        {
          "key": "a",
          "text": "ii, iv"
        },
        {
          "key": "b",
          "text": "iii, v"
        },
        {
          "key": "c",
          "text": "i, ii, v"
        },
        {
          "key": "d",
          "text": "i, iii, iv"
        }
      ],
      "correctAnswer": [
        "a"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is correct. Items ii (test data) and iv (test procedures - documented sequences of test cases) are produced as a result of test implementation",
        "b": "Is not correct. Test environment requirements (iii) is output of test design and test cases (v) is output of test design",
        "c": "Is not correct. Test completion report (i) is output of test completion",
        "d": "Is not correct. Test completion report (i) is output of test completion and test environment requirements (iii) is output of test design"
      },
      "learningObjective": "FL-1.4.3",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 6,
      "questionText": "Which of the following is MOST likely to describe a task performed by someone in a test management role?",
      "options": [
        {
          "key": "a",
          "text": "Evaluate the test basis and the test object"
        },
        {
          "key": "b",
          "text": "Define test environment requirements"
        },
        {
          "key": "c",
          "text": "Assess testability of the test object"
        },
        {
          "key": "d",
          "text": "Create the test completion report"
        }
      ],
      "correctAnswer": [
        "d"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. The testing role is primarily responsible for the technical and engineering aspects of testing, such as test analysis, test design, test implementation, and test execution. Evaluating the test basis for defects and the test object for testability are tasks performed as part of test analysis, so it is likely they are tasks performed by the testing role",
        "b": "Is not correct. The testing role is primarily responsible for the technical and engineering aspects of testing, such as test analysis, test design, test implementation, and test execution. Defining the test environment requirements is a task performed as part of test design, so it is likely to be a task performed by the testing role",
        "c": "Is not correct. The testing role is primarily responsible for the technical and engineering aspects of testing, such as test analysis, test design, test implementation, and test execution. Assessing the testability of a test object is a task performed as part of test analysis, so it is likely to be a task performed by the testing role",
        "d": "Is correct. The test management role primarily involves activities related to test planning, test monitoring and test control, and test completion. Thus, creating the test completion report, which is the prime output from the test completion, is likely to be a task performed by the test management role"
      },
      "learningObjective": "FL-1.4.5",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 7,
      "questionText": "Which of the following is an advantage of the whole team approach?",
      "options": [
        {
          "key": "a",
          "text": "Improved communication between team members"
        },
        {
          "key": "b",
          "text": "Decreased individual accountability for quality"
        },
        {
          "key": "c",
          "text": "Faster deployment of deliverables to the end users"
        },
        {
          "key": "d",
          "text": "Reduced collaboration with external business users"
        }
      ],
      "correctAnswer": [
        "a"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is correct. The whole team approach promotes robust communication and collaboration between the team members",
        "b": "Is not correct. While the whole team approach prioritizes collective accountability for quality, each individual team member is still equally accountable for quality",
        "c": "Is not correct. The whole team approach is about how the team works together, with the aim of higher quality deliverables, but it does not necessarily result in faster deployment to end users",
        "d": "Is not correct. When using the whole team approach, testers work with business representatives to create acceptance tests. There is no suggestion that the approach will reduce collaboration with external business users"
      },
      "learningObjective": "FL-1.5.2",
      "kLevel": "K1",
      "points": 1
    },
    {
      "id": 8,
      "questionText": "Given the following benefits and drawbacks of the independence of testing:\ni. The testers work in a different location from the developers\nii. Testers question the assumptions programmers make while writing code\niii. A confrontational dynamic has been established between testers and developers\niv. Developers have convinced themselves that testers are mostly accountable for quality\nv. Testers have different biases than those held by the developers\n\nWhich are MOST likely to be considered benefits?",
      "options": [
        {
          "key": "a",
          "text": "i, iv"
        },
        {
          "key": "b",
          "text": "ii, v"
        },
        {
          "key": "c",
          "text": "i, iii, iv"
        },
        {
          "key": "d",
          "text": "ii, iii, v"
        }
      ],
      "correctAnswer": [
        "b"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct",
        "b": "Is correct. The list entries showing benefits are ii (Testers and developers have varied backgrounds, technical viewpoints, and potential biases, allowing testers to usefully challenge assumptions made by stakeholders during system specification and implementation) and v (The primary benefit of independence of testing is that testers are more likely to identify different types of failures and defects compared to developers, due to their varied backgrounds, technical viewpoints, and potential biases, including cognitive bias)",
        "c": "Is not correct",
        "d": "Is not correct"
      },
      "learningObjective": "FL-1.5.3",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 9,
      "questionText": "Which of the following is a good testing practice that applies to all software development lifecycles?",
      "options": [
        {
          "key": "a",
          "text": "Each test level has specific and distinct test objectives"
        },
        {
          "key": "b",
          "text": "Test implementation and execution for a given test level should start during the corresponding development phase"
        },
        {
          "key": "c",
          "text": "Testers should start test design as soon as drafts of the relevant work products become available"
        },
        {
          "key": "d",
          "text": "Every dynamic testing activity has a corresponding static testing activity"
        }
      ],
      "correctAnswer": [
        "a"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is correct. Each test level has specific and distinct test objectives as a different form of test object (e.g., single component and complete system) is tested at each test level and overlapping test objectives would lead to unnecessary duplication",
        "b": "Is not correct. Test analysis and test design for a given test level should start during the corresponding development phase to facilitate early testing (e.g., acceptance test analysis and test design should begin during requirements analysis). Test implementation will generally start later, and test execution will start during the test level",
        "c": "Is not correct. Test design for a given test level should start during the corresponding development phase to facilitate early testing, however test design (e.g., test case generation) needs to be based on an agreed test basis, not an early draft, otherwise significant test effort may be wasted on creating test cases for a design that later changes",
        "d": "Is not correct. Quality control applies to all development activities, meaning that every software development activity has a corresponding test activity. However, the same symmetry does not apply to dynamic testing and static testing. There are some static testing activities (e.g., static analysis) for which there is no obvious corresponding dynamic testing activity"
      },
      "learningObjective": "FL-2.1.2",
      "kLevel": "K1",
      "points": 1
    },
    {
      "id": 10,
      "questionText": "Which of the following is an example of a test-first approach to development?",
      "options": [
        {
          "key": "a",
          "text": "Behavior-Driven Development"
        },
        {
          "key": "b",
          "text": "Test Level Driven Development"
        },
        {
          "key": "c",
          "text": "Function-Driven Development"
        },
        {
          "key": "d",
          "text": "Performance-Driven Development"
        }
      ],
      "correctAnswer": [
        "a"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is correct. Behavior-Driven Development (BDD) is a well-known example of a test-first approach to development",
        "b": "Is not correct. Test Level Driven Development is not a correct example of a test-first approach to development",
        "c": "Is not correct. Function-Driven Development is not a correct example of a test-first approach to development",
        "d": "Is not correct. Performance-Driven Development is not a correct example of a test-first approach to development"
      },
      "learningObjective": "FL-2.1.3",
      "kLevel": "K1",
      "points": 1
    },
    {
      "id": 11,
      "questionText": "Which of the following is MOST likely to be a challenge encountered when implementing DevOps?",
      "options": [
        {
          "key": "a",
          "text": "Making sure that non-functional quality characteristics are not overlooked"
        },
        {
          "key": "b",
          "text": "Managing continuously changing test environments"
        },
        {
          "key": "c",
          "text": "The need for more manual testers with suitable experience"
        },
        {
          "key": "d",
          "text": "Setting up the test automation as part of the delivery pipeline"
        }
      ],
      "correctAnswer": [
        "d"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. DevOps generally increases the visibility of non-functional quality characteristics, such as performance and reliability",
        "b": "Is not correct. Automated processes like continuous integration/continuous delivery (CI/CD) used in DevOps facilitate stable test environments",
        "c": "Is not correct. Automated processes like CI/CD used in DevOps generally reduce the need for manual testing",
        "d": "Is correct. DevOps implementation can pose several risks and challenges, including the need to define and set up the delivery pipeline, introduce and maintain CI/CD tools, and establish and maintain test automation"
      },
      "learningObjective": "FL-2.1.4",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 12,
      "questionText": "Which of the following BEST describes retrospectives?",
      "options": [
        {
          "key": "a",
          "text": "Retrospectives allow team members to identify other team members who did not fully contribute to achieving quality as required by the whole team approach"
        },
        {
          "key": "b",
          "text": "Retrospectives give testers an opportunity to identify activities that were successful so that these are retained when potential improvements are made in the future"
        },
        {
          "key": "c",
          "text": "Retrospectives are where agile team members are allowed to voice their concerns about management and customers in a blameless environment"
        },
        {
          "key": "d",
          "text": "Retrospectives give agile team members a forum where they focus on discussing the plan and technical decisions for the next iteration"
        }
      ],
      "correctAnswer": [
        "b"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. The benefits of retrospectives include team bonding and learning from sharing issues, and better collaboration between developers and testers through reviewing and improving working practices. Calling out individuals who a team member may feel did not fully contribute to achieving quality as required by the whole team approach will not contribute to this team bonding and collaboration",
        "b": "Is correct. During the retrospective, the group discusses what aspects of the project were successful and should be retained, as well as areas that could be improved, and how to do so",
        "c": "Is not correct. The benefits of retrospectives are based on increased effectiveness and efficiency through process improvements; they are not an opportunity to let off steam and criticize management and customers. Also, the test results are recorded, usually in the test completion report, so anything said in the meeting could be read by other stakeholders",
        "d": "Is not correct. Retrospectives are meetings that are typically held at the end of an iteration where team members will focus on discussing quality-related issues that have occurred in the current iteration. They are not used for making plans or technical decisions for the next iteration; this would be done in the iteration planning meeting at the start of the next iteration"
      },
      "learningObjective": "FL-2.1.6",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 13,
      "questionText": "Which of the following tests is MOST likely to be performed as part of functional testing?",
      "options": [
        {
          "key": "a",
          "text": "The test checks that the sort function puts the elements of the list or array in ascending order"
        },
        {
          "key": "b",
          "text": "The test checks whether the sort function completes sorting within one second of starting"
        },
        {
          "key": "c",
          "text": "The test checks how easily the sort function can be changed from sorting ascending to sorting descending"
        },
        {
          "key": "d",
          "text": "The test checks that the sort function still functions correctly when moved from a 32-bit to a 64-bit architecture"
        }
      ],
      "correctAnswer": [
        "a"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is correct. Checking that the sort function puts the elements of the list or array in ascending order is evaluating the functional correctness of the sort function, which is part of functional testing",
        "b": "Is not correct. Assessing whether the sort function meets its non-functional requirement to complete within one second is part of testing its performance efficiency, which is part of non-functional testing",
        "c": "Is not correct. Evaluating the ease with which the sort function can be modified from sorting ascending to sorting descending is testing its modifiability, a form of non-functional maintainability testing, which is part of non-functional testing",
        "d": "Is not correct. Assessing that the sort function still functions correctly when moved from a 32-bit to a 64-bit architecture is testing its adaptability, a form of portability testing, which is part of non-functional testing"
      },
      "learningObjective": "FL-2.2.2",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 14,
      "questionText": "Which of the following is MOST likely to be a trigger that leads to maintenance testing of a currency exchange system?",
      "options": [
        {
          "key": "a",
          "text": "The developers reported that changing the currency exchange system was difficult and the testers decided to check if this was true"
        },
        {
          "key": "b",
          "text": "The refund option of the currency exchange system was removed as it did not always repay the correct amount to customers"
        },
        {
          "key": "c",
          "text": "The agile team has started developing a user story that adds a new customer loyalty feature to the currency exchange system"
        },
        {
          "key": "d",
          "text": "The language support option of the currency exchange system was used to enable both English and local language currency transactions"
        }
      ],
      "correctAnswer": [
        "b"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. Assuming that testers could check the ease of changing the currency exchange system then it would be done by maintainability testing rather than maintenance testing, so this is not a trigger for maintenance testing",
        "b": "Is correct. A system modification (such as a fix or enhancement) is an example of a trigger for maintenance testing. The removal of the refund option of the currency exchange system was a fix that would lead to maintenance testing",
        "c": "Is not correct. If the agile team has started developing a user story that adds a new customer loyalty feature to the currency exchange system, then this will result in them testing the new feature, and then they would perform regression testing. No maintenance testing is required in this situation",
        "d": "Is not correct. Reconfiguration of the currency exchange system to support both the local language and English currency transactions is not a system modification, a change to the operational environment, or a system retirement, which are the three triggers for maintenance testing"
      },
      "learningObjective": "FL-2.3.1",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 15,
      "questionText": "Which of the following CANNOT be examined by static testing?",
      "options": [
        {
          "key": "a",
          "text": "Contract"
        },
        {
          "key": "b",
          "text": "Test plan"
        },
        {
          "key": "c",
          "text": "Encrypted code"
        },
        {
          "key": "d",
          "text": "Test charter"
        }
      ],
      "correctAnswer": [
        "c"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. Most work products can be examined using some form of static testing, and a contract must be interpretable by humans and so could be reviewed, which is a form of static testing",
        "b": "Is not correct. Most work products can be examined using some form of static testing, and a test plan must be interpretable by humans and so could be reviewed, which is a form of static testing",
        "c": "Is correct. Most work products can be examined using some form of static testing; however it is not suitable for work products that are too complex for human interpretation and should not be analyzed by tools, and encrypted code is too complex for humans and if it is properly encrypted it will not be analyzable by most tools",
        "d": "Is not correct. Most work products can be examined using some form of static testing, and a test charter must be interpretable by humans and so could be reviewed, which is a form of static testing"
      },
      "learningObjective": "FL-3.1.1",
      "kLevel": "K1",
      "points": 1
    },
    {
      "id": 16,
      "questionText": "Which of the following statements about the value of static testing is CORRECT?",
      "options": [
        {
          "key": "a",
          "text": "The defect types found by static testing are different from the defect types that can be found by dynamic testing"
        },
        {
          "key": "b",
          "text": "Dynamic testing can detect the defect types that can be found by static testing plus some additional defect types"
        },
        {
          "key": "c",
          "text": "Dynamic testing can identify some of the defects that can be found by static testing but not all of them"
        },
        {
          "key": "d",
          "text": "Static testing can identify the defect types that can be found by dynamic testing as well as some extra defect types"
        }
      ],
      "correctAnswer": [
        "c"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. Some defect types can be found by both static testing and dynamic testing, such as a programming defect that can be observed by a reviewer in a code review and which causes an observable failure during dynamic testing",
        "b": "Is not correct. There are some defect types that can only be detected by static testing, such as unreachable code, design patterns not implemented as desired and defects in non-executable work products",
        "c": "Is correct. Some defect types that can only be detected by static testing, such as unreachable code, design patterns not implemented as desired and defects in non-executable work products. Some defect types that can be found by both static testing and dynamic testing, such as a programming defect that can be observed by a reviewer in a code review and which causes an observable failure during dynamic testing. And some defect types that can only be detected by dynamic testing, such as performance issues or memory issues that can only be observed when executing the code or system",
        "d": "Is not correct. There are some defect types that can only be detected by dynamic testing, such as performance issues or memory issues that can only be observed when executing the code or system"
      },
      "learningObjective": "FL-3.1.2",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 17,
      "questionText": "Given the following descriptions of review activities:\n1. Detected anomalies are deliberated upon, and determinations are reached regarding their status, ownership, and any further steps needed\n2. Defects are recorded, and any needed updates are addressed prior to the acceptance of the work product\n3. Reviewers employ techniques to come up with suggestions and questions about the work product and to spot anomalies\n4. The objective of the review and its schedule are established to ensure a focused and efficient review\n5. Participants are provided with access to the item being reviewed\n\nWhich of the following is the CORRECT sequence in the review process of the activities that correspond to the descriptions?",
      "options": [
        {
          "key": "a",
          "text": "4 – 3 – 5 – 2 – 1"
        },
        {
          "key": "b",
          "text": "4 – 5 – 3 – 1 – 2"
        },
        {
          "key": "c",
          "text": "5 – 4 – 1 – 3 – 2"
        },
        {
          "key": "d",
          "text": "5 – 4 – 3 – 2 – 1"
        }
      ],
      "correctAnswer": [
        "b"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct",
        "b": "Is correct. The correct sequence of activities is: 4 (Planning) – 5 (Review initiation) – 3 (Individual review) – 1 (Communication and analysis) – 2 (Fixing and reporting)",
        "c": "Is not correct",
        "d": "Is not correct"
      },
      "learningObjective": "FL-3.2.2",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 18,
      "questionText": "Which participant in the review process is responsible for ensuring that the review meetings run effectively and that everyone at the meetings can voice their opinions freely?",
      "options": [
        {
          "key": "a",
          "text": "Manager"
        },
        {
          "key": "b",
          "text": "Moderator"
        },
        {
          "key": "c",
          "text": "Chairperson"
        },
        {
          "key": "d",
          "text": "Review Leader"
        }
      ],
      "correctAnswer": [
        "b"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. The manager is responsible for deciding what needs to be reviewed and allocating resources, such as staff and time, for the review",
        "b": "Is correct. The moderator (or facilitator) is responsible for ensuring that the review meetings run effectively, including managing time, mediating discussions, and creating a safe environment where everyone can voice their opinions freely",
        "c": "Is not correct. The chairperson is not a recognized role in reviews",
        "d": "Is not correct. The review leader is responsible for overseeing the review process, such as selecting the review team members, scheduling review meetings, and ensuring that the review is completed successfully"
      },
      "learningObjective": "FL-3.2.3",
      "kLevel": "K1",
      "points": 1
    },
    {
      "id": 19,
      "questionText": "You perform system testing of an e-commerce web application and are provided with the following requirement:\n\nREQ 05-017. If the total cost of purchases exceeds $100, the customer gets a 5% discount on subsequent purchases. Otherwise, the customer does not receive a discount.\n\nWhich test techniques will be MOST helpful in designing test cases based on this requirement?",
      "options": [
        {
          "key": "a",
          "text": "White-box test techniques"
        },
        {
          "key": "b",
          "text": "Black-box test techniques"
        },
        {
          "key": "c",
          "text": "Experience-based test techniques"
        },
        {
          "key": "d",
          "text": "Risk-based test techniques"
        }
      ],
      "correctAnswer": [
        "b"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. The document does not refer to the test object's internal structure but specifies the desired behavior of the test object. Therefore, white-box test techniques will not be helpful in designing test cases",
        "b": "Is correct. The document is a requirement that specifies the desired behavior of the test object. Therefore, the most suitable test techniques in this case are the black-box test techniques (e.g., Boundary Value Analysis or Decision Table Testing)",
        "c": "Is not correct. Although experience-based test techniques can be used to design test cases based on this document, black-box test techniques will be more suitable. The document describes a precise business rule and, in addition, wording like \"exceeds $100\" suggests the existence of important equivalence partition boundaries that should be tested using black-box test techniques like Boundary Value Analysis",
        "d": "Is not correct. Risk-based test techniques are not a recognized type of test technique"
      },
      "learningObjective": "FL-4.1.1",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 20,
      "questionText": "The system for selling cinema tickets calculates the discount type based on the client's birth year (BY) and on the current year (CY) as follows:\n\nLet D be the difference between CY and BY, that is, D = CY – BY\n• If D < 0 then print the error message \"birth year cannot be greater than current year\"\n• If 0 ≤ D < 18 then apply the student discount\n• If 18 ≤ D < 65 then apply no discount\n• If D ≥ 65 then apply the pensioner discount\n\nYour test suite already contains two test cases:\n• BY = 1990, CY = 2020, expected result: no discount\n• BY = 2030, CY = 2029, expected result: print the error message\n\nWhich of the following test data sets should be added to achieve full valid equivalence partitioning coverage for the discount type?",
      "options": [
        {
          "key": "a",
          "text": "BY = 2001, CY = 2065"
        },
        {
          "key": "b",
          "text": "BY = 1900, CY = 1965"
        },
        {
          "key": "c",
          "text": "BY = 1965, CY = 1900"
        },
        {
          "key": "d",
          "text": "BY = 2011, CY = 2029"
        },
        {
          "key": "e",
          "text": "BY = 2000, CY = 2000"
        }
      ],
      "correctAnswer": [
        "b",
        "e"
      ],
      "selectType": "multiple",
      "explanation": {
        "a": "Is not correct. CY – BY = 64, so these inputs correspond to the already covered \"no discount\" partition",
        "b": "Is correct. CY – BY = 65, so these inputs correspond to a partition that is not yet covered (\"pensioner discount\")",
        "c": "Is not correct. CY – BY = –65, so these inputs correspond to the already covered \"error message\" partition",
        "d": "Is not correct. CY – BY = 18, so these inputs correspond to the already covered \"no discount\" partition",
        "e": "Is correct. CY – BY = 0, so these inputs correspond to a partition that is not yet covered (\"student discount\")"
      },
      "learningObjective": "FL-4.2.1",
      "kLevel": "K3",
      "points": 1
    },
    {
      "id": 21,
      "questionText": "You are testing a temperature control system for a horticultural cold storage facility. The system receives the temperature (in full degrees Celsius) as the input. If the temperature is between 0 and 2 degrees inclusive, the system displays the message \"temperature OK\". For lower temperatures, the system displays the message \"temperature too low\" and for higher temperatures it displays the message \"temperature too high\".\n\nUsing two-value boundary value analysis, which of the following sets of test inputs provides the highest level of boundary value coverage?",
      "options": [
        {
          "key": "a",
          "text": "–1, 3"
        },
        {
          "key": "b",
          "text": "0, 2"
        },
        {
          "key": "c",
          "text": "–1, 0, 2, 3"
        },
        {
          "key": "d",
          "text": "–2, 0, 2, 4"
        }
      ],
      "correctAnswer": [
        "c"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. This covers only 2 out of 4 boundary values",
        "b": "Is not correct. This covers only 2 out of 4 boundary values",
        "c": "Is correct. The correct option is: –1, 0, 2, 3. There are three equivalence partitions: {..., –2, –1}, {0, 1, 2}, {3, 4, ...}. For 2-value BVA all the boundary values for all the equivalence partitions must be covered. The boundary values are –1 (for the \"temperature too low\" partition), 0, 2 (for the \"temperature OK\" partition) and 3 (for the \"temperature too high\" partition)",
        "d": "Is not correct. –2 and 4 are not boundary values"
      },
      "learningObjective": "FL-4.2.2",
      "kLevel": "K3",
      "points": 1
    },
    {
      "id": 22,
      "questionText": "You are designing test cases based on the following decision table.\n\n| | R1 | R2 | R3 | R4 | R5 | R6 | R7 |\n|C1: Age|0-18|19-65|19-65|>65|0-18|19-65|>65|\n|C2: Experience|-|0-4|>4|-|-|-|-|\n|C3: Registered?|NO|NO|NO|NO|YES|YES|YES|\n|Category|A|A|B|B|B|D|C|\n\nSo far you have designed the following test cases:\n• TC1: 19-year-old, unregistered man with no experience; expected result: category A\n• TC2: 65-year-old, unregistered woman with 5 years of experience; expected result: category B\n• TC3: 66-year-old, registered man with no experience; expected result: category C\n• TC4: 65-year-old, registered woman with 4 years of experience; expected result: category D\n\nWhich of the following test cases, when added to the existing set of test cases, will increase the decision table coverage?",
      "options": [
        {
          "key": "a",
          "text": "66-year-old, unregistered man with no experience; expected result: category B"
        },
        {
          "key": "b",
          "text": "55-year-old, unregistered woman with 2 years of experience; expected result: category A"
        },
        {
          "key": "c",
          "text": "19-year-old, registered woman with 5 years of experience; expected result: category D"
        },
        {
          "key": "d",
          "text": "No additional test case can increase the already achieved decision table coverage"
        }
      ],
      "correctAnswer": [
        "a"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is correct. The conditions \"66-year-old\", \"unregistered\" and \"no experience\" match rule R4, which is not covered by the existing test cases, so after adding this test case, the decision table coverage will increase",
        "b": "Is not correct. The conditions \"55-year-old\", \"unregistered\" and \"2 years of experience\" match rule R2, already covered by TC1. So adding this test case will not increase the coverage",
        "c": "Is not correct. The conditions \"19-year-old\", \"registered\" and \"5 years of experience\" match rule R6, already covered by TC4. So adding this test case will not increase the coverage",
        "d": "Is not correct. The existing test cases cover only 4 out of 7 columns of the decision table. The coverage can be increased by adding test cases that cover yet uncovered columns, that is, R1, R4 and R5"
      },
      "learningObjective": "FL-4.2.3",
      "kLevel": "K3",
      "points": 1
    },
    {
      "id": 23,
      "questionText": "You are applying state transition testing to the hotel room reservation system modeled by the following state transition table, with 4 states and 5 different events:\n\n|State|Available|NotAvailable|ChangeRoom|Cancel|Pay|\n|S1: Requesting|S2|S3| | | |\n|S2: Confirmed| | |S1|S4|S4|\n|S3: Waiting list|S2| | |S4| |\n|S4: End| | | | | |\n\nAssuming all test cases start in the 'Requesting' state, which of the following test cases, represented as sequences of events, achieves the highest valid transitions coverage?",
      "options": [
        {
          "key": "a",
          "text": "NotAvailable, Available, ChangeRoom, NotAvailable, Cancel"
        },
        {
          "key": "b",
          "text": "Available, ChangeRoom, NotAvailable, Available, Pay"
        },
        {
          "key": "c",
          "text": "Available, ChangeRoom, Available, ChangeRoom, NotAvailable"
        },
        {
          "key": "d",
          "text": "NotAvailable, Cancel, ChangeRoom, Available, Pay"
        }
      ],
      "correctAnswer": [
        "b"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. This sequence of five events covers 4 different valid transitions (both \"NotAvailable\" events correspond to the same transition between S1 and S3). This test case covers 4 out of 7 valid transitions",
        "b": "Is correct. This sequence of five events covers 5 different transitions (the first \"Available\" event corresponds to a transition between S1 and S2, and the second \"Available\" event corresponds to a transition between S3 and S2, so two different transitions are covered). This test case covers 5 out of 7 valid transitions and achieves the highest valid transitions coverage",
        "c": "Is not correct. This sequence of five events covers 3 different transitions (both \"Available\" events correspond to the same transition from S1 to S2; both \"ChangeRoom\" events correspond to the same transition from S2 to S1). This test case covers 3 out of 7 valid transitions",
        "d": "Is not correct. This sequence of five events does not represent a feasible test case, because after \"Cancel\" the system ends up in the End state and no further valid transitions can be executed"
      },
      "learningObjective": "FL-4.2.4",
      "kLevel": "K3",
      "points": 1
    },
    {
      "id": 24,
      "questionText": "Your test suite S for a program P achieves 100% statement coverage. It consists of three test cases, each of which achieves 50% statement coverage.\n\nWhich of the following statements is CORRECT?",
      "options": [
        {
          "key": "a",
          "text": "Executing S will cause all possible failures in P"
        },
        {
          "key": "b",
          "text": "S achieves 100% branch coverage for P"
        },
        {
          "key": "c",
          "text": "Every executable statement in P containing a defect has been run at least once during the execution of S"
        },
        {
          "key": "d",
          "text": "After removing one test case from S, the remaining two test cases will still achieve 100% statement coverage"
        }
      ],
      "correctAnswer": [
        "c"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. A statement with a defect, when executed, does not have to cause a failure. For example, a statement x := y / z will cause a failure only when z equals 0",
        "b": "Is not correct. 100% statement coverage does not guarantee 100% branch coverage. For example, a test case with x=0 for the code 1. IF (x=0) THEN 2. A; 3. ENDIF achieves 100% statement coverage but does not cover the branch from 1 to 3",
        "c": "Is correct. 100% statement coverage means that each executable statement was executed at least once",
        "d": "Is not correct. The removed test case may provide coverage of some statements that are not covered by either of the other two test cases, in which case the remaining two test cases together will not achieve 100% statement coverage"
      },
      "learningObjective": "FL-4.3.1",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 25,
      "questionText": "Why does white-box testing facilitate defect detection even when the software specification is vague, outdated or incomplete?",
      "options": [
        {
          "key": "a",
          "text": "Test cases are designed based on the structure of the test object rather than the specification"
        },
        {
          "key": "b",
          "text": "For each white-box test technique the coverage can be well-defined and easily measured"
        },
        {
          "key": "c",
          "text": "White-box test techniques are very well designed to detect omissions in the requirements"
        },
        {
          "key": "d",
          "text": "White-box test techniques can be used in both static testing and dynamic testing"
        }
      ],
      "correctAnswer": [
        "a"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is correct. A fundamental strength that all white-box test techniques share is that the entire software implementation is taken into account during testing, which facilitates defect detection even when the software specification is vague, outdated or incomplete. This means white-box testing can find defects such as an extra feature added to the code (either accidentally or deliberately) that is not supposed to be there, which black-box testing cannot detect",
        "b": "Is not correct. The fact that the coverage can be precisely defined is not the right reason. The achieved level of coverage would have much more impact than the possibility to measure the coverage",
        "c": "Is not correct. If the software does not implement one or more requirements, white-box testing is unlikely to detect the resulting defects of omission",
        "d": "Is not correct. While this is true, this is not the right answer, because there is no connection between the capability to be used in both static testing and dynamic testing and the claim that white-box testing facilitates defect detection with poor specifications"
      },
      "learningObjective": "FL-4.3.3",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 26,
      "questionText": "Which of the following is NOT anticipated by the tester while applying error guessing?",
      "options": [
        {
          "key": "a",
          "text": "The developer misunderstood the formula in the user story for calculating the interest"
        },
        {
          "key": "b",
          "text": "The developer wrote \"FA = A*(1+IR^N)\" instead of \"FA = A*(1+IR)^N\" in the source code"
        },
        {
          "key": "c",
          "text": "The developer missed the seminar on new compound interest rate legislation"
        },
        {
          "key": "d",
          "text": "The accuracy of the interest calculated by the system is not precise enough"
        }
      ],
      "correctAnswer": [
        "c"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. This is an example of anticipating the developer's error",
        "b": "Is not correct. This is an example of anticipating the defect",
        "c": "Is correct. This is an example of a potential root cause of a defect, which is neither an error, defect nor failure, and difficult for the tester to anticipate",
        "d": "Is not correct. This is an example of anticipating a failure, perhaps based on experience of previous systems in this application domain"
      },
      "learningObjective": "FL-4.4.1",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 27,
      "questionText": "Which of the following is true about exploratory testing?",
      "options": [
        {
          "key": "a",
          "text": "Test cases are designed before the exploratory testing session starts"
        },
        {
          "key": "b",
          "text": "The tester can perform test execution, but cannot perform test design"
        },
        {
          "key": "c",
          "text": "Exploratory testing results are good predictors of the number of remaining defects"
        },
        {
          "key": "d",
          "text": "During exploratory testing the tester may use black-box test techniques"
        }
      ],
      "correctAnswer": [
        "d"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. In exploratory testing, test cases are usually created during the exploratory testing session, alongside test analysis, test implementation and test execution",
        "b": "Is not correct. In exploratory testing, tests are simultaneously designed, executed, and evaluated while the tester learns about the test object",
        "c": "Is not correct. Exploratory test results depend heavily on the tester's experience. So, even if the test results of exploratory testing can be used as a predictor of risk and used to assess whether there will be fewer or more defects, compared to the previous exploratory testing session, they are not a good example of reliable defect prediction models that can predict the number of remaining defects",
        "d": "Is correct. During exploratory testing, the testers can use any test techniques that they find useful"
      },
      "learningObjective": "FL-4.4.2",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 28,
      "questionText": "Which collaborative user story writing practice enables the team to achieve a collective understanding of what needs to be delivered?",
      "options": [
        {
          "key": "a",
          "text": "Planning poker, so that a team can achieve consensus on the effort needed to implement a user story"
        },
        {
          "key": "b",
          "text": "Reviews, so that a team can detect inconsistencies and contradictions in a user story"
        },
        {
          "key": "c",
          "text": "Iteration planning, so that user stories with the highest business value for a customer can be prioritized for implementation"
        },
        {
          "key": "d",
          "text": "Conversation, so that team members can understand how the software will be used"
        }
      ],
      "correctAnswer": [
        "d"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. Planning poker can estimate effort for a user story that is already written. It does not help in understanding what should be delivered",
        "b": "Is not correct. Reviews are not a collaborative user story writing practice",
        "c": "Is not correct. Iteration planning is a project-related practice, used to plan the work, not to understand what needs to be delivered",
        "d": "Is correct. Conversation explains how the software will be used and often allows the team to define meaningful acceptance criteria, thus obtaining a shared vision of what should be delivered"
      },
      "learningObjective": "FL-4.5.1",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 29,
      "questionText": "You have just started designing test cases for the following user story.\n\nAs a customer,\nI want to be able to filter search results by price range, so that I can find products within my budget more easily.\n\nAcceptance criteria:\n1. The filter should work for all versions of the application from version 3.0 upwards\n2. The filter should allow the customer to set a price range with a minimum and a maximum price\n3. The search results should update dynamically as the customer adjusts the price range filter\n\nIn all test cases the precondition is as follows: there are only two products available, products A and B. Product A costs $100 and product B costs $110.\n\nWhich of the following is the BEST example of a test case for this user story?",
      "options": [
        {
          "key": "a",
          "text": "Enter webpage and set filter to show prices between $90 and $100. Expected result: results show product A only. Set maximum price to $110. Expected result: results now include both products A and B"
        },
        {
          "key": "b",
          "text": "Enter webpage. Expected result: the default minimum and maximum prices are $100 and $110 respectively. Add product C to stock, with price $120. Refresh the client's webpage. Expected result: the default maximum price changes to $120"
        },
        {
          "key": "c",
          "text": "Enter webpage and set filter to show prices between $90 and $115. Expected result: results show both products A and B. Change currency from USD to EUR. Expected result: the filter range changes correctly to EUR values, according to the current exchange rate"
        },
        {
          "key": "d",
          "text": "Enter webpage with three different browsers: Edge, Chrome and Opera. In each browser set filter between $90 and $110. Expected result: results include both products A and B and the results layout is the same in all three browsers"
        }
      ],
      "correctAnswer": [
        "a"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is correct. This test case is related to acceptance criteria 2 and 3, because we check if we can set price range (acceptance criterion 2) and if the results update dynamically after adjusting the price range filter (acceptance criterion 3)",
        "b": "Is not correct. This test case is not related to any of the acceptance criteria. It checks if the filter dynamically sets the default minimum and maximum price range, and not that a customer can do it",
        "c": "Is not correct. This test case is not related to any of the acceptance criteria. It checks the currency exchange feature, which is not discussed in this user story",
        "d": "Is not correct. This test case is not related to any of the acceptance criteria. It checks the application's compatibility with different browsers, which is not discussed in this user story"
      },
      "learningObjective": "FL-4.5.3",
      "kLevel": "K3",
      "points": 1
    },
    {
      "id": 30,
      "questionText": "Which of the following BEST define EXIT criteria in a testing project?",
      "options": [
        {
          "key": "a",
          "text": "Budget is approved"
        },
        {
          "key": "b",
          "text": "Budget runs out"
        },
        {
          "key": "c",
          "text": "Test basis is available"
        },
        {
          "key": "d",
          "text": "Test cases achieved at least 80% statement coverage"
        },
        {
          "key": "e",
          "text": "All test analysts are ISTQB certified at the Foundation Level"
        }
      ],
      "correctAnswer": [
        "b",
        "d"
      ],
      "selectType": "multiple",
      "explanation": {
        "a": "Is not correct. The approval of the budget is an example of an entry criterion. It would make no sense to approve the budget for some activity that has already been done",
        "b": "Is correct. Running out of budget can be viewed as a valid exit criterion",
        "c": "Is not correct. Availability of resources is an example of an entry criterion for testing",
        "d": "Is correct. Coverage is a measure of thoroughness, so it is a typical exit criterion",
        "e": "Is not correct. This is an example of an entry criterion, checked before the project starts"
      },
      "learningObjective": "FL-5.1.3",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 31,
      "questionText": "The team wants to estimate the time needed for one tester to execute four test cases for a software component. The team has gathered the following measures of the effort used to execute a single test case:\n• Best-case scenario: 1 hour\n• Worst-case scenario: 8 hours\n• Most likely scenario: 3 hours\n\nGiven that the three-point estimation technique is being used, what is the final estimate of the time needed to execute all four test cases?",
      "options": [
        {
          "key": "a",
          "text": "14 hours"
        },
        {
          "key": "b",
          "text": "3.5 hours"
        },
        {
          "key": "c",
          "text": "16 hours"
        },
        {
          "key": "d",
          "text": "12 hours"
        }
      ],
      "correctAnswer": [
        "a"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is correct. Using the three-point estimation technique, the final estimate (E) is calculated as: E = (a + 4*m + b) / 6, where a is the most optimistic estimate, m is the most likely estimate, and b is the most pessimistic estimate. In this case, the estimate for executing a single test case is: E = (1h + 4*3h + 8h) / 6 = 3.5 hours. So, the total time needed for the tester to execute 4 test cases is: 3.5h * 4 = 14 hours",
        "b": "Is not correct. This is the time for one test case, not four",
        "c": "Is not correct",
        "d": "Is not correct"
      },
      "learningObjective": "FL-5.1.4",
      "kLevel": "K3",
      "points": 1
    },
    {
      "id": 32,
      "questionText": "The table shows the traceability matrix from test cases to requirements. \"X\" means that a given test case covers the corresponding requirement.\n\n| |Req1|Req2|Req3|Req4|Req5|Req6|Req7|\n|TC1|X| |X|X| | |X|\n|TC2|X| | | |X| |X|\n|TC3| | | | |X|X| |\n|TC4| |X| | | | | |\n\nYou want to prioritize the test cases following the additional coverage prioritization technique.\n\nYou execute all four test cases.\n\nWhich test case should be executed as the LAST one?",
      "options": [
        {
          "key": "a",
          "text": "TC1"
        },
        {
          "key": "b",
          "text": "TC2"
        },
        {
          "key": "c",
          "text": "TC3"
        },
        {
          "key": "d",
          "text": "TC4"
        }
      ],
      "correctAnswer": [
        "b"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct",
        "b": "Is correct. TC1 achieves the highest coverage (4/7 – Req1, Req3, Req4 and Req7), so should be executed first. Req2, Req5 and Req6 are still not covered. The next test case that achieves the highest additional coverage of the remaining requirements is TC3, covering 2 out of these 3 requirements (Req5 and Req6). So, TC3 should be executed as the second one. Now the only requirement still not covered is Req2, which is covered by TC4. Therefore, TC4 should be executed as the third test case. So, the last test case executed will be TC2",
        "c": "Is not correct",
        "d": "Is not correct"
      },
      "learningObjective": "FL-5.1.5",
      "kLevel": "K3",
      "points": 1
    },
    {
      "id": 33,
      "questionText": "How can the testing quadrants be beneficial for testing?",
      "options": [
        {
          "key": "a",
          "text": "They help in test planning by dividing the test process into four phases, corresponding to the four basic test levels: component, integration, system, and acceptance testing"
        },
        {
          "key": "b",
          "text": "They help in assessing the high-level coverage (e.g., requirements coverage) based on low-level coverage (e.g., code coverage)"
        },
        {
          "key": "c",
          "text": "They help non-technical stakeholders to understand the different test types and that some test types are more relevant to certain test levels than others"
        },
        {
          "key": "d",
          "text": "They help agile teams to develop a communication strategy based on classifying people according to four basic psychological types, and on modelling the relations between them"
        }
      ],
      "correctAnswer": [
        "c"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. Testing quadrants have nothing to do with describing the relationships between test levels",
        "b": "Is not correct. Testing quadrants cannot help in assessing any type of coverage",
        "c": "Is correct. Testing quadrants allow managers and other stakeholders to understand the relationships between test types, the activities they support (team support or product critique), and the viewpoint they are focused on (business- or technology-facing)",
        "d": "Is not correct. Testing quadrants is not a psychological model"
      },
      "learningObjective": "FL-5.1.7",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 34,
      "questionText": "For a given risk, its risk level is $1,000 and its risk likelihood is estimated as 50%.\n\nWhat is the risk impact?",
      "options": [
        {
          "key": "a",
          "text": "$500"
        },
        {
          "key": "b",
          "text": "$2,000"
        },
        {
          "key": "c",
          "text": "$50,000"
        },
        {
          "key": "d",
          "text": "$200"
        }
      ],
      "correctAnswer": [
        "b"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct",
        "b": "Is correct. Risk assessment can use a quantitative or qualitative approach, or a mix of them. In the quantitative approach the risk level is calculated as the multiplication of risk likelihood and risk impact. So, Risk level = Risk likelihood * Risk impact. Then, Risk impact = Risk level / Risk likelihood. In our case, Risk impact = $1,000 / 50% = $1,000 / 0.5 = $2,000",
        "c": "Is not correct",
        "d": "Is not correct"
      },
      "learningObjective": "FL-5.2.1",
      "kLevel": "K1",
      "points": 1
    },
    {
      "id": 35,
      "questionText": "Which of the following are product risks?",
      "options": [
        {
          "key": "a",
          "text": "Scope creep"
        },
        {
          "key": "b",
          "text": "Poor architecture"
        },
        {
          "key": "c",
          "text": "Cost-cutting"
        },
        {
          "key": "d",
          "text": "Poor tool support"
        },
        {
          "key": "e",
          "text": "Too long response time"
        }
      ],
      "correctAnswer": [
        "b",
        "e"
      ],
      "selectType": "multiple",
      "explanation": {
        "a": "Is not correct. Scope creep is an example of a project risk related to technical issues",
        "b": "Is correct. Poor architecture is an example of a product risk since it refers to a product characteristic",
        "c": "Is not correct. Cost-cutting is an example of a project risk, related to organizational issues",
        "d": "Is not correct. Poor tool support is an example of a project risk related to technical issues",
        "e": "Is correct. Response time that is too long is an example of a product risk since it refers to a product characteristic"
      },
      "learningObjective": "FL-5.2.2",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 36,
      "questionText": "Which of the following is NOT a valid purpose for a test report?",
      "options": [
        {
          "key": "a",
          "text": "Tracking test progress and identifying areas that require further attention"
        },
        {
          "key": "b",
          "text": "Providing information on the tests executed, their results, and defects found"
        },
        {
          "key": "c",
          "text": "Providing information about each defect, such as the steps to reproduce it"
        },
        {
          "key": "d",
          "text": "Providing information on testing planned for the next period"
        }
      ],
      "correctAnswer": [
        "c"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. Tracking test progress and identifying areas that require further attention is an example of supporting the ongoing control of testing. This is one of the purposes of test reports",
        "b": "Is not correct. Providing information on the tests executed, their test results, and any defects found is an example of summarizing the test activities performed at a given test level. This is one of the purposes of test reports",
        "c": "Is correct. Providing information about defects is the purpose of a defect report, not a test report",
        "d": "Is not correct. Providing information on testing planned for the next period is one of the purposes of test reports"
      },
      "learningObjective": "FL-5.3.2",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 37,
      "questionText": "The user reported a software failure. An engineer from the support team asked the user for the software version number where the failure was observed. Based on the version number, the team reassembled all the files that made up the release. This later allowed a developer to perform analysis, find the defect, and fix it.\n\nWhich of the following enabled the above activity to be performed by the team?",
      "options": [
        {
          "key": "a",
          "text": "Risk management"
        },
        {
          "key": "b",
          "text": "Test monitoring and control"
        },
        {
          "key": "c",
          "text": "Whole team approach"
        },
        {
          "key": "d",
          "text": "Configuration management"
        }
      ],
      "correctAnswer": [
        "d"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. Risk management consists of risk analysis and risk control. Neither of these activities supports the reassembly of the files that made up the release, because these activities deal with risks, not with configuration items",
        "b": "Is not correct. Test monitoring is concerned with gathering information about testing. This information is used to assess test progress and to measure whether the exit criteria or the test tasks associated with the exit criteria are satisfied, such as meeting the targets for coverage of product risks, requirements, or other acceptance criteria. Test control uses the information from test monitoring to provide, in the form of control directives, guidance and the necessary corrective actions to achieve the most effective and efficient testing. None of these activities deal with the management of configuration items",
        "c": "Is not correct. The whole team approach builds on the tester's skill to work effectively in a team context and to contribute positively to the team goals. So, it focuses on team-related issues, not on configuration items",
        "d": "Is correct. Configuration management provides a discipline for identifying, controlling, and tracking work products. Configuration management keeps a record of changed configuration items when a new baseline is created. Using configuration management, it is possible to revert to a previous baseline in order to reproduce previous test results"
      },
      "learningObjective": "FL-5.4.1",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 38,
      "questionText": "Consider the following defect report for a Book Lending System.\n\nDefect ID: 001 | Title: Unable to Return a Book |\nSeverity: High | Priority: |\nEnvironment: Windows 10, Google Chrome\n\nDescription: When attempting to return a book using the Book Return feature, the system does not register the return and the book remains checked out to the user.\n\nSteps to Reproduce:\nLogin to the Book Lending System as a user who has checked out a book.\nClick on the \"Book Return\" button for the book that has been checked out.\nSystem does not register the return and the book remains checked out.\n\nExpected Result: The book should be returned and no longer appear as checked out to the user.\nActual Result: The book remains checked out to the user and is not registered as returned in the system.\n\nAttachments: [empty list]\n\nWhich of the following is MOST likely to help the developer reproduce the failure quickly?",
      "options": [
        {
          "key": "a",
          "text": "Adding information about which users and which books the failure affects to the \"Description\" section"
        },
        {
          "key": "b",
          "text": "Filling in the missing value for the \"Priority\" field"
        },
        {
          "key": "c",
          "text": "Adding memory dumps and database snapshots taken after each step described in the \"Steps to Reproduce\" section to the \"Attachments\" section."
        },
        {
          "key": "d",
          "text": "Repeating the same test case for different environments and writing defect reports for each of them separately"
        }
      ],
      "correctAnswer": [
        "a"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is correct. Adding this information allows the developer to use the same input data, so it is more likely they will be able to reproduce the failure quickly and so identify the defect faster",
        "b": "Is not correct. Adding the value of Priority will not help in reproducing the defect itself",
        "c": "Is not correct. Although some of this information may be of value, adding the memory dumps and database snapshots after each step will be too much, because most of these artefacts will contain useless information for the developer, and make the defect report less readable. It will also require the developer to spend a lot of time analyzing this information, which will lengthen the repair process",
        "d": "Is not correct. The question was about helping the developer to reproduce the failure for a specific environment configuration"
      },
      "learningObjective": "FL-5.5.1",
      "kLevel": "K3",
      "points": 1
    },
    {
      "id": 39,
      "questionText": "Given the following test tool categories:\ni. Collaboration tools\nii. DevOps tools\niii. Management tools\niv. Non-functional testing tools\nv. Test design and implementation tools\n\nTools from which of the categories are MOST likely to facilitate test execution?",
      "options": [
        {
          "key": "a",
          "text": "i, v"
        },
        {
          "key": "b",
          "text": "ii, iv"
        },
        {
          "key": "c",
          "text": "i, iii, v"
        },
        {
          "key": "d",
          "text": "ii, iii, iv"
        }
      ],
      "correctAnswer": [
        "b"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct",
        "b": "Is correct. Both DevOps tools (ii) and Non-functional testing tools (iv) facilitate test execution. DevOps tools support the DevOps delivery pipeline, workflow tracking, automated build process(es) and CI/CD. The delivery pipeline and CI/CD both include the facilitation of test execution, such as component testing for CI. Non-functional testing tools allow the tester to perform non-functional testing that is difficult or impossible to perform manually. Non-functional testing can include both static testing and dynamic testing, including test execution",
        "c": "Is not correct",
        "d": "Is not correct"
      },
      "learningObjective": "FL-6.1.1",
      "kLevel": "K2",
      "points": 1
    },
    {
      "id": 40,
      "questionText": "Which of the following is MOST likely to be a risk of test automation?",
      "options": [
        {
          "key": "a",
          "text": "The detection of additional high-severity defects"
        },
        {
          "key": "b",
          "text": "Providing measures that are too complicated for humans to derive"
        },
        {
          "key": "c",
          "text": "Incompatibility with the development platform"
        },
        {
          "key": "d",
          "text": "Substantially reduced test execution times"
        }
      ],
      "correctAnswer": [
        "c"
      ],
      "selectType": "single",
      "explanation": {
        "a": "Is not correct. The detection of additional high-severity defects would be a benefit of test automation, rather than a risk",
        "b": "Is not correct. The provision of measures that are too complicated for humans to derive themselves is normally considered to be a benefit of test automation",
        "c": "Is correct. If the test automation is incompatible with the development platform, then it will not be able to integrate them, and, for instance, pass test inputs to the test object and receive test results from the test object",
        "d": "Is not correct. Substantially reduced test execution times would normally be considered a benefit that is provided by test automation"
      },
      "learningObjective": "FL-6.2.1",
      "kLevel": "K1",
      "points": 1
    }
  ]
}